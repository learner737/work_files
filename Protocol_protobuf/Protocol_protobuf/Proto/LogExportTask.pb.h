// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LogExportTask.proto

#ifndef PROTOBUF_LogExportTask_2eproto__INCLUDED
#define PROTOBUF_LogExportTask_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace LogExportTask {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_LogExportTask_2eproto();
void protobuf_AssignDesc_LogExportTask_2eproto();
void protobuf_ShutdownFile_LogExportTask_2eproto();

class Task;
class DownLoadSingleFileTask;
class DownLoadHandlersFileListTask;
class Handler;
class HandlerFile;

enum TaskHandler {
  EN_TASK_HANDLE_WEB = 1,
  EN_TASK_HANDLE_MESSAGE = 2,
  EN_TASK_HANDLE_MYSQL = 3,
  EN_TASK_HANDLE_STORAGE = 4,
  EN_TASK_HANDLE_COMPUTE = 5,
  EN_TASK_HANDLE_CLIENT = 6
};
bool TaskHandler_IsValid(int value);
const TaskHandler TaskHandler_MIN = EN_TASK_HANDLE_WEB;
const TaskHandler TaskHandler_MAX = EN_TASK_HANDLE_CLIENT;
const int TaskHandler_ARRAYSIZE = TaskHandler_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskHandler_descriptor();
inline const ::std::string& TaskHandler_Name(TaskHandler value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskHandler_descriptor(), value);
}
inline bool TaskHandler_Parse(
    const ::std::string& name, TaskHandler* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskHandler>(
    TaskHandler_descriptor(), name, value);
}
// ===================================================================

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();
  
  Task(const Task& from);
  
  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();
  
  void Swap(Task* other);
  
  // implements Message ----------------------------------------------
  
  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes task_uuid = 1;
  inline bool has_task_uuid() const;
  inline void clear_task_uuid();
  static const int kTaskUuidFieldNumber = 1;
  inline const ::std::string& task_uuid() const;
  inline void set_task_uuid(const ::std::string& value);
  inline void set_task_uuid(const char* value);
  inline void set_task_uuid(const void* value, size_t size);
  inline ::std::string* mutable_task_uuid();
  
  // required int32 task_timeout_second = 2;
  inline bool has_task_timeout_second() const;
  inline void clear_task_timeout_second();
  static const int kTaskTimeoutSecondFieldNumber = 2;
  inline ::google::protobuf::int32 task_timeout_second() const;
  inline void set_task_timeout_second(::google::protobuf::int32 value);
  
  // required .LogExportTask.TaskHandler task_handler = 3;
  inline bool has_task_handler() const;
  inline void clear_task_handler();
  static const int kTaskHandlerFieldNumber = 3;
  inline LogExportTask::TaskHandler task_handler() const;
  inline void set_task_handler(LogExportTask::TaskHandler value);
  
  // required bytes task_handler_userid = 4;
  inline bool has_task_handler_userid() const;
  inline void clear_task_handler_userid();
  static const int kTaskHandlerUseridFieldNumber = 4;
  inline const ::std::string& task_handler_userid() const;
  inline void set_task_handler_userid(const ::std::string& value);
  inline void set_task_handler_userid(const char* value);
  inline void set_task_handler_userid(const void* value, size_t size);
  inline ::std::string* mutable_task_handler_userid();
  
  // @@protoc_insertion_point(class_scope:LogExportTask.Task)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* task_uuid_;
  static const ::std::string _default_task_uuid_;
  ::google::protobuf::int32 task_timeout_second_;
  int task_handler_;
  ::std::string* task_handler_userid_;
  static const ::std::string _default_task_handler_userid_;
  friend void  protobuf_AddDesc_LogExportTask_2eproto();
  friend void protobuf_AssignDesc_LogExportTask_2eproto();
  friend void protobuf_ShutdownFile_LogExportTask_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class DownLoadSingleFileTask : public ::google::protobuf::Message {
 public:
  DownLoadSingleFileTask();
  virtual ~DownLoadSingleFileTask();
  
  DownLoadSingleFileTask(const DownLoadSingleFileTask& from);
  
  inline DownLoadSingleFileTask& operator=(const DownLoadSingleFileTask& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DownLoadSingleFileTask& default_instance();
  
  void Swap(DownLoadSingleFileTask* other);
  
  // implements Message ----------------------------------------------
  
  DownLoadSingleFileTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownLoadSingleFileTask& from);
  void MergeFrom(const DownLoadSingleFileTask& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes task_uuid = 1;
  inline bool has_task_uuid() const;
  inline void clear_task_uuid();
  static const int kTaskUuidFieldNumber = 1;
  inline const ::std::string& task_uuid() const;
  inline void set_task_uuid(const ::std::string& value);
  inline void set_task_uuid(const char* value);
  inline void set_task_uuid(const void* value, size_t size);
  inline ::std::string* mutable_task_uuid();
  
  // required int32 task_timeout_second = 2;
  inline bool has_task_timeout_second() const;
  inline void clear_task_timeout_second();
  static const int kTaskTimeoutSecondFieldNumber = 2;
  inline ::google::protobuf::int32 task_timeout_second() const;
  inline void set_task_timeout_second(::google::protobuf::int32 value);
  
  // required .LogExportTask.TaskHandler task_handler = 3;
  inline bool has_task_handler() const;
  inline void clear_task_handler();
  static const int kTaskHandlerFieldNumber = 3;
  inline LogExportTask::TaskHandler task_handler() const;
  inline void set_task_handler(LogExportTask::TaskHandler value);
  
  // required bytes task_handler_userid = 4;
  inline bool has_task_handler_userid() const;
  inline void clear_task_handler_userid();
  static const int kTaskHandlerUseridFieldNumber = 4;
  inline const ::std::string& task_handler_userid() const;
  inline void set_task_handler_userid(const ::std::string& value);
  inline void set_task_handler_userid(const char* value);
  inline void set_task_handler_userid(const void* value, size_t size);
  inline ::std::string* mutable_task_handler_userid();
  
  // required bytes filename = 5;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 5;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const void* value, size_t size);
  inline ::std::string* mutable_filename();
  
  // required int64 fileindex = 6;
  inline bool has_fileindex() const;
  inline void clear_fileindex();
  static const int kFileindexFieldNumber = 6;
  inline ::google::protobuf::int64 fileindex() const;
  inline void set_fileindex(::google::protobuf::int64 value);
  
  // required int64 filesize_byte = 7;
  inline bool has_filesize_byte() const;
  inline void clear_filesize_byte();
  static const int kFilesizeByteFieldNumber = 7;
  inline ::google::protobuf::int64 filesize_byte() const;
  inline void set_filesize_byte(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:LogExportTask.DownLoadSingleFileTask)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* task_uuid_;
  static const ::std::string _default_task_uuid_;
  ::google::protobuf::int32 task_timeout_second_;
  int task_handler_;
  ::std::string* task_handler_userid_;
  static const ::std::string _default_task_handler_userid_;
  ::std::string* filename_;
  static const ::std::string _default_filename_;
  ::google::protobuf::int64 fileindex_;
  ::google::protobuf::int64 filesize_byte_;
  friend void  protobuf_AddDesc_LogExportTask_2eproto();
  friend void protobuf_AssignDesc_LogExportTask_2eproto();
  friend void protobuf_ShutdownFile_LogExportTask_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DownLoadSingleFileTask* default_instance_;
};
// -------------------------------------------------------------------

class DownLoadHandlersFileListTask : public ::google::protobuf::Message {
 public:
  DownLoadHandlersFileListTask();
  virtual ~DownLoadHandlersFileListTask();
  
  DownLoadHandlersFileListTask(const DownLoadHandlersFileListTask& from);
  
  inline DownLoadHandlersFileListTask& operator=(const DownLoadHandlersFileListTask& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DownLoadHandlersFileListTask& default_instance();
  
  void Swap(DownLoadHandlersFileListTask* other);
  
  // implements Message ----------------------------------------------
  
  DownLoadHandlersFileListTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownLoadHandlersFileListTask& from);
  void MergeFrom(const DownLoadHandlersFileListTask& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes task_uuid = 1;
  inline bool has_task_uuid() const;
  inline void clear_task_uuid();
  static const int kTaskUuidFieldNumber = 1;
  inline const ::std::string& task_uuid() const;
  inline void set_task_uuid(const ::std::string& value);
  inline void set_task_uuid(const char* value);
  inline void set_task_uuid(const void* value, size_t size);
  inline ::std::string* mutable_task_uuid();
  
  // required int32 task_timeout_second = 2;
  inline bool has_task_timeout_second() const;
  inline void clear_task_timeout_second();
  static const int kTaskTimeoutSecondFieldNumber = 2;
  inline ::google::protobuf::int32 task_timeout_second() const;
  inline void set_task_timeout_second(::google::protobuf::int32 value);
  
  // required bytes bug_description = 3;
  inline bool has_bug_description() const;
  inline void clear_bug_description();
  static const int kBugDescriptionFieldNumber = 3;
  inline const ::std::string& bug_description() const;
  inline void set_bug_description(const ::std::string& value);
  inline void set_bug_description(const char* value);
  inline void set_bug_description(const void* value, size_t size);
  inline ::std::string* mutable_bug_description();
  
  // repeated .LogExportTask.Handler handler_list = 4;
  inline int handler_list_size() const;
  inline void clear_handler_list();
  static const int kHandlerListFieldNumber = 4;
  inline const ::LogExportTask::Handler& handler_list(int index) const;
  inline ::LogExportTask::Handler* mutable_handler_list(int index);
  inline ::LogExportTask::Handler* add_handler_list();
  inline const ::google::protobuf::RepeatedPtrField< ::LogExportTask::Handler >&
      handler_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::LogExportTask::Handler >*
      mutable_handler_list();
  
  // @@protoc_insertion_point(class_scope:LogExportTask.DownLoadHandlersFileListTask)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* task_uuid_;
  static const ::std::string _default_task_uuid_;
  ::google::protobuf::int32 task_timeout_second_;
  ::std::string* bug_description_;
  static const ::std::string _default_bug_description_;
  ::google::protobuf::RepeatedPtrField< ::LogExportTask::Handler > handler_list_;
  friend void  protobuf_AddDesc_LogExportTask_2eproto();
  friend void protobuf_AssignDesc_LogExportTask_2eproto();
  friend void protobuf_ShutdownFile_LogExportTask_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DownLoadHandlersFileListTask* default_instance_;
};
// -------------------------------------------------------------------

class Handler : public ::google::protobuf::Message {
 public:
  Handler();
  virtual ~Handler();
  
  Handler(const Handler& from);
  
  inline Handler& operator=(const Handler& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Handler& default_instance();
  
  void Swap(Handler* other);
  
  // implements Message ----------------------------------------------
  
  Handler* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Handler& from);
  void MergeFrom(const Handler& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .LogExportTask.TaskHandler task_handler = 1;
  inline bool has_task_handler() const;
  inline void clear_task_handler();
  static const int kTaskHandlerFieldNumber = 1;
  inline LogExportTask::TaskHandler task_handler() const;
  inline void set_task_handler(LogExportTask::TaskHandler value);
  
  // required bytes task_handler_userid = 2;
  inline bool has_task_handler_userid() const;
  inline void clear_task_handler_userid();
  static const int kTaskHandlerUseridFieldNumber = 2;
  inline const ::std::string& task_handler_userid() const;
  inline void set_task_handler_userid(const ::std::string& value);
  inline void set_task_handler_userid(const char* value);
  inline void set_task_handler_userid(const void* value, size_t size);
  inline ::std::string* mutable_task_handler_userid();
  
  // required bytes task_sub_uuid = 3;
  inline bool has_task_sub_uuid() const;
  inline void clear_task_sub_uuid();
  static const int kTaskSubUuidFieldNumber = 3;
  inline const ::std::string& task_sub_uuid() const;
  inline void set_task_sub_uuid(const ::std::string& value);
  inline void set_task_sub_uuid(const char* value);
  inline void set_task_sub_uuid(const void* value, size_t size);
  inline ::std::string* mutable_task_sub_uuid();
  
  // repeated .LogExportTask.HandlerFile handler_file_list = 4;
  inline int handler_file_list_size() const;
  inline void clear_handler_file_list();
  static const int kHandlerFileListFieldNumber = 4;
  inline const ::LogExportTask::HandlerFile& handler_file_list(int index) const;
  inline ::LogExportTask::HandlerFile* mutable_handler_file_list(int index);
  inline ::LogExportTask::HandlerFile* add_handler_file_list();
  inline const ::google::protobuf::RepeatedPtrField< ::LogExportTask::HandlerFile >&
      handler_file_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::LogExportTask::HandlerFile >*
      mutable_handler_file_list();
  
  // @@protoc_insertion_point(class_scope:LogExportTask.Handler)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int task_handler_;
  ::std::string* task_handler_userid_;
  static const ::std::string _default_task_handler_userid_;
  ::std::string* task_sub_uuid_;
  static const ::std::string _default_task_sub_uuid_;
  ::google::protobuf::RepeatedPtrField< ::LogExportTask::HandlerFile > handler_file_list_;
  friend void  protobuf_AddDesc_LogExportTask_2eproto();
  friend void protobuf_AssignDesc_LogExportTask_2eproto();
  friend void protobuf_ShutdownFile_LogExportTask_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Handler* default_instance_;
};
// -------------------------------------------------------------------

class HandlerFile : public ::google::protobuf::Message {
 public:
  HandlerFile();
  virtual ~HandlerFile();
  
  HandlerFile(const HandlerFile& from);
  
  inline HandlerFile& operator=(const HandlerFile& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HandlerFile& default_instance();
  
  void Swap(HandlerFile* other);
  
  // implements Message ----------------------------------------------
  
  HandlerFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HandlerFile& from);
  void MergeFrom(const HandlerFile& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 filetype = 1;
  inline bool has_filetype() const;
  inline void clear_filetype();
  static const int kFiletypeFieldNumber = 1;
  inline ::google::protobuf::int32 filetype() const;
  inline void set_filetype(::google::protobuf::int32 value);
  
  // required int64 fileindex = 2;
  inline bool has_fileindex() const;
  inline void clear_fileindex();
  static const int kFileindexFieldNumber = 2;
  inline ::google::protobuf::int64 fileindex() const;
  inline void set_fileindex(::google::protobuf::int64 value);
  
  // required bytes filename = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const void* value, size_t size);
  inline ::std::string* mutable_filename();
  
  // required int64 filesize_byte = 4;
  inline bool has_filesize_byte() const;
  inline void clear_filesize_byte();
  static const int kFilesizeByteFieldNumber = 4;
  inline ::google::protobuf::int64 filesize_byte() const;
  inline void set_filesize_byte(::google::protobuf::int64 value);
  
  // required bytes lastupdatetime = 5;
  inline bool has_lastupdatetime() const;
  inline void clear_lastupdatetime();
  static const int kLastupdatetimeFieldNumber = 5;
  inline const ::std::string& lastupdatetime() const;
  inline void set_lastupdatetime(const ::std::string& value);
  inline void set_lastupdatetime(const char* value);
  inline void set_lastupdatetime(const void* value, size_t size);
  inline ::std::string* mutable_lastupdatetime();
  
  // @@protoc_insertion_point(class_scope:LogExportTask.HandlerFile)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 filetype_;
  ::google::protobuf::int64 fileindex_;
  ::std::string* filename_;
  static const ::std::string _default_filename_;
  ::google::protobuf::int64 filesize_byte_;
  ::std::string* lastupdatetime_;
  static const ::std::string _default_lastupdatetime_;
  friend void  protobuf_AddDesc_LogExportTask_2eproto();
  friend void protobuf_AssignDesc_LogExportTask_2eproto();
  friend void protobuf_ShutdownFile_LogExportTask_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static HandlerFile* default_instance_;
};
// ===================================================================


// ===================================================================

// Task

// required bytes task_uuid = 1;
inline bool Task::has_task_uuid() const {
  return _has_bit(0);
}
inline void Task::clear_task_uuid() {
  if (task_uuid_ != &_default_task_uuid_) {
    task_uuid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Task::task_uuid() const {
  return *task_uuid_;
}
inline void Task::set_task_uuid(const ::std::string& value) {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  task_uuid_->assign(value);
}
inline void Task::set_task_uuid(const char* value) {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  task_uuid_->assign(value);
}
inline void Task::set_task_uuid(const void* value, size_t size) {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  task_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task::mutable_task_uuid() {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  return task_uuid_;
}

// required int32 task_timeout_second = 2;
inline bool Task::has_task_timeout_second() const {
  return _has_bit(1);
}
inline void Task::clear_task_timeout_second() {
  task_timeout_second_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Task::task_timeout_second() const {
  return task_timeout_second_;
}
inline void Task::set_task_timeout_second(::google::protobuf::int32 value) {
  _set_bit(1);
  task_timeout_second_ = value;
}

// required .LogExportTask.TaskHandler task_handler = 3;
inline bool Task::has_task_handler() const {
  return _has_bit(2);
}
inline void Task::clear_task_handler() {
  task_handler_ = 1;
  _clear_bit(2);
}
inline LogExportTask::TaskHandler Task::task_handler() const {
  return static_cast< LogExportTask::TaskHandler >(task_handler_);
}
inline void Task::set_task_handler(LogExportTask::TaskHandler value) {
  GOOGLE_DCHECK(LogExportTask::TaskHandler_IsValid(value));
  _set_bit(2);
  task_handler_ = value;
}

// required bytes task_handler_userid = 4;
inline bool Task::has_task_handler_userid() const {
  return _has_bit(3);
}
inline void Task::clear_task_handler_userid() {
  if (task_handler_userid_ != &_default_task_handler_userid_) {
    task_handler_userid_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Task::task_handler_userid() const {
  return *task_handler_userid_;
}
inline void Task::set_task_handler_userid(const ::std::string& value) {
  _set_bit(3);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  task_handler_userid_->assign(value);
}
inline void Task::set_task_handler_userid(const char* value) {
  _set_bit(3);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  task_handler_userid_->assign(value);
}
inline void Task::set_task_handler_userid(const void* value, size_t size) {
  _set_bit(3);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  task_handler_userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task::mutable_task_handler_userid() {
  _set_bit(3);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  return task_handler_userid_;
}

// -------------------------------------------------------------------

// DownLoadSingleFileTask

// required bytes task_uuid = 1;
inline bool DownLoadSingleFileTask::has_task_uuid() const {
  return _has_bit(0);
}
inline void DownLoadSingleFileTask::clear_task_uuid() {
  if (task_uuid_ != &_default_task_uuid_) {
    task_uuid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DownLoadSingleFileTask::task_uuid() const {
  return *task_uuid_;
}
inline void DownLoadSingleFileTask::set_task_uuid(const ::std::string& value) {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  task_uuid_->assign(value);
}
inline void DownLoadSingleFileTask::set_task_uuid(const char* value) {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  task_uuid_->assign(value);
}
inline void DownLoadSingleFileTask::set_task_uuid(const void* value, size_t size) {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  task_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownLoadSingleFileTask::mutable_task_uuid() {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  return task_uuid_;
}

// required int32 task_timeout_second = 2;
inline bool DownLoadSingleFileTask::has_task_timeout_second() const {
  return _has_bit(1);
}
inline void DownLoadSingleFileTask::clear_task_timeout_second() {
  task_timeout_second_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 DownLoadSingleFileTask::task_timeout_second() const {
  return task_timeout_second_;
}
inline void DownLoadSingleFileTask::set_task_timeout_second(::google::protobuf::int32 value) {
  _set_bit(1);
  task_timeout_second_ = value;
}

// required .LogExportTask.TaskHandler task_handler = 3;
inline bool DownLoadSingleFileTask::has_task_handler() const {
  return _has_bit(2);
}
inline void DownLoadSingleFileTask::clear_task_handler() {
  task_handler_ = 1;
  _clear_bit(2);
}
inline LogExportTask::TaskHandler DownLoadSingleFileTask::task_handler() const {
  return static_cast< LogExportTask::TaskHandler >(task_handler_);
}
inline void DownLoadSingleFileTask::set_task_handler(LogExportTask::TaskHandler value) {
  GOOGLE_DCHECK(LogExportTask::TaskHandler_IsValid(value));
  _set_bit(2);
  task_handler_ = value;
}

// required bytes task_handler_userid = 4;
inline bool DownLoadSingleFileTask::has_task_handler_userid() const {
  return _has_bit(3);
}
inline void DownLoadSingleFileTask::clear_task_handler_userid() {
  if (task_handler_userid_ != &_default_task_handler_userid_) {
    task_handler_userid_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& DownLoadSingleFileTask::task_handler_userid() const {
  return *task_handler_userid_;
}
inline void DownLoadSingleFileTask::set_task_handler_userid(const ::std::string& value) {
  _set_bit(3);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  task_handler_userid_->assign(value);
}
inline void DownLoadSingleFileTask::set_task_handler_userid(const char* value) {
  _set_bit(3);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  task_handler_userid_->assign(value);
}
inline void DownLoadSingleFileTask::set_task_handler_userid(const void* value, size_t size) {
  _set_bit(3);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  task_handler_userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownLoadSingleFileTask::mutable_task_handler_userid() {
  _set_bit(3);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  return task_handler_userid_;
}

// required bytes filename = 5;
inline bool DownLoadSingleFileTask::has_filename() const {
  return _has_bit(4);
}
inline void DownLoadSingleFileTask::clear_filename() {
  if (filename_ != &_default_filename_) {
    filename_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& DownLoadSingleFileTask::filename() const {
  return *filename_;
}
inline void DownLoadSingleFileTask::set_filename(const ::std::string& value) {
  _set_bit(4);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void DownLoadSingleFileTask::set_filename(const char* value) {
  _set_bit(4);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void DownLoadSingleFileTask::set_filename(const void* value, size_t size) {
  _set_bit(4);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownLoadSingleFileTask::mutable_filename() {
  _set_bit(4);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  return filename_;
}

// required int64 fileindex = 6;
inline bool DownLoadSingleFileTask::has_fileindex() const {
  return _has_bit(5);
}
inline void DownLoadSingleFileTask::clear_fileindex() {
  fileindex_ = GOOGLE_LONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::int64 DownLoadSingleFileTask::fileindex() const {
  return fileindex_;
}
inline void DownLoadSingleFileTask::set_fileindex(::google::protobuf::int64 value) {
  _set_bit(5);
  fileindex_ = value;
}

// required int64 filesize_byte = 7;
inline bool DownLoadSingleFileTask::has_filesize_byte() const {
  return _has_bit(6);
}
inline void DownLoadSingleFileTask::clear_filesize_byte() {
  filesize_byte_ = GOOGLE_LONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::int64 DownLoadSingleFileTask::filesize_byte() const {
  return filesize_byte_;
}
inline void DownLoadSingleFileTask::set_filesize_byte(::google::protobuf::int64 value) {
  _set_bit(6);
  filesize_byte_ = value;
}

// -------------------------------------------------------------------

// DownLoadHandlersFileListTask

// required bytes task_uuid = 1;
inline bool DownLoadHandlersFileListTask::has_task_uuid() const {
  return _has_bit(0);
}
inline void DownLoadHandlersFileListTask::clear_task_uuid() {
  if (task_uuid_ != &_default_task_uuid_) {
    task_uuid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DownLoadHandlersFileListTask::task_uuid() const {
  return *task_uuid_;
}
inline void DownLoadHandlersFileListTask::set_task_uuid(const ::std::string& value) {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  task_uuid_->assign(value);
}
inline void DownLoadHandlersFileListTask::set_task_uuid(const char* value) {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  task_uuid_->assign(value);
}
inline void DownLoadHandlersFileListTask::set_task_uuid(const void* value, size_t size) {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  task_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownLoadHandlersFileListTask::mutable_task_uuid() {
  _set_bit(0);
  if (task_uuid_ == &_default_task_uuid_) {
    task_uuid_ = new ::std::string;
  }
  return task_uuid_;
}

// required int32 task_timeout_second = 2;
inline bool DownLoadHandlersFileListTask::has_task_timeout_second() const {
  return _has_bit(1);
}
inline void DownLoadHandlersFileListTask::clear_task_timeout_second() {
  task_timeout_second_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 DownLoadHandlersFileListTask::task_timeout_second() const {
  return task_timeout_second_;
}
inline void DownLoadHandlersFileListTask::set_task_timeout_second(::google::protobuf::int32 value) {
  _set_bit(1);
  task_timeout_second_ = value;
}

// required bytes bug_description = 3;
inline bool DownLoadHandlersFileListTask::has_bug_description() const {
  return _has_bit(2);
}
inline void DownLoadHandlersFileListTask::clear_bug_description() {
  if (bug_description_ != &_default_bug_description_) {
    bug_description_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& DownLoadHandlersFileListTask::bug_description() const {
  return *bug_description_;
}
inline void DownLoadHandlersFileListTask::set_bug_description(const ::std::string& value) {
  _set_bit(2);
  if (bug_description_ == &_default_bug_description_) {
    bug_description_ = new ::std::string;
  }
  bug_description_->assign(value);
}
inline void DownLoadHandlersFileListTask::set_bug_description(const char* value) {
  _set_bit(2);
  if (bug_description_ == &_default_bug_description_) {
    bug_description_ = new ::std::string;
  }
  bug_description_->assign(value);
}
inline void DownLoadHandlersFileListTask::set_bug_description(const void* value, size_t size) {
  _set_bit(2);
  if (bug_description_ == &_default_bug_description_) {
    bug_description_ = new ::std::string;
  }
  bug_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownLoadHandlersFileListTask::mutable_bug_description() {
  _set_bit(2);
  if (bug_description_ == &_default_bug_description_) {
    bug_description_ = new ::std::string;
  }
  return bug_description_;
}

// repeated .LogExportTask.Handler handler_list = 4;
inline int DownLoadHandlersFileListTask::handler_list_size() const {
  return handler_list_.size();
}
inline void DownLoadHandlersFileListTask::clear_handler_list() {
  handler_list_.Clear();
}
inline const ::LogExportTask::Handler& DownLoadHandlersFileListTask::handler_list(int index) const {
  return handler_list_.Get(index);
}
inline ::LogExportTask::Handler* DownLoadHandlersFileListTask::mutable_handler_list(int index) {
  return handler_list_.Mutable(index);
}
inline ::LogExportTask::Handler* DownLoadHandlersFileListTask::add_handler_list() {
  return handler_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LogExportTask::Handler >&
DownLoadHandlersFileListTask::handler_list() const {
  return handler_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::LogExportTask::Handler >*
DownLoadHandlersFileListTask::mutable_handler_list() {
  return &handler_list_;
}

// -------------------------------------------------------------------

// Handler

// required .LogExportTask.TaskHandler task_handler = 1;
inline bool Handler::has_task_handler() const {
  return _has_bit(0);
}
inline void Handler::clear_task_handler() {
  task_handler_ = 1;
  _clear_bit(0);
}
inline LogExportTask::TaskHandler Handler::task_handler() const {
  return static_cast< LogExportTask::TaskHandler >(task_handler_);
}
inline void Handler::set_task_handler(LogExportTask::TaskHandler value) {
  GOOGLE_DCHECK(LogExportTask::TaskHandler_IsValid(value));
  _set_bit(0);
  task_handler_ = value;
}

// required bytes task_handler_userid = 2;
inline bool Handler::has_task_handler_userid() const {
  return _has_bit(1);
}
inline void Handler::clear_task_handler_userid() {
  if (task_handler_userid_ != &_default_task_handler_userid_) {
    task_handler_userid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Handler::task_handler_userid() const {
  return *task_handler_userid_;
}
inline void Handler::set_task_handler_userid(const ::std::string& value) {
  _set_bit(1);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  task_handler_userid_->assign(value);
}
inline void Handler::set_task_handler_userid(const char* value) {
  _set_bit(1);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  task_handler_userid_->assign(value);
}
inline void Handler::set_task_handler_userid(const void* value, size_t size) {
  _set_bit(1);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  task_handler_userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Handler::mutable_task_handler_userid() {
  _set_bit(1);
  if (task_handler_userid_ == &_default_task_handler_userid_) {
    task_handler_userid_ = new ::std::string;
  }
  return task_handler_userid_;
}

// required bytes task_sub_uuid = 3;
inline bool Handler::has_task_sub_uuid() const {
  return _has_bit(2);
}
inline void Handler::clear_task_sub_uuid() {
  if (task_sub_uuid_ != &_default_task_sub_uuid_) {
    task_sub_uuid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Handler::task_sub_uuid() const {
  return *task_sub_uuid_;
}
inline void Handler::set_task_sub_uuid(const ::std::string& value) {
  _set_bit(2);
  if (task_sub_uuid_ == &_default_task_sub_uuid_) {
    task_sub_uuid_ = new ::std::string;
  }
  task_sub_uuid_->assign(value);
}
inline void Handler::set_task_sub_uuid(const char* value) {
  _set_bit(2);
  if (task_sub_uuid_ == &_default_task_sub_uuid_) {
    task_sub_uuid_ = new ::std::string;
  }
  task_sub_uuid_->assign(value);
}
inline void Handler::set_task_sub_uuid(const void* value, size_t size) {
  _set_bit(2);
  if (task_sub_uuid_ == &_default_task_sub_uuid_) {
    task_sub_uuid_ = new ::std::string;
  }
  task_sub_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Handler::mutable_task_sub_uuid() {
  _set_bit(2);
  if (task_sub_uuid_ == &_default_task_sub_uuid_) {
    task_sub_uuid_ = new ::std::string;
  }
  return task_sub_uuid_;
}

// repeated .LogExportTask.HandlerFile handler_file_list = 4;
inline int Handler::handler_file_list_size() const {
  return handler_file_list_.size();
}
inline void Handler::clear_handler_file_list() {
  handler_file_list_.Clear();
}
inline const ::LogExportTask::HandlerFile& Handler::handler_file_list(int index) const {
  return handler_file_list_.Get(index);
}
inline ::LogExportTask::HandlerFile* Handler::mutable_handler_file_list(int index) {
  return handler_file_list_.Mutable(index);
}
inline ::LogExportTask::HandlerFile* Handler::add_handler_file_list() {
  return handler_file_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LogExportTask::HandlerFile >&
Handler::handler_file_list() const {
  return handler_file_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::LogExportTask::HandlerFile >*
Handler::mutable_handler_file_list() {
  return &handler_file_list_;
}

// -------------------------------------------------------------------

// HandlerFile

// required int32 filetype = 1;
inline bool HandlerFile::has_filetype() const {
  return _has_bit(0);
}
inline void HandlerFile::clear_filetype() {
  filetype_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 HandlerFile::filetype() const {
  return filetype_;
}
inline void HandlerFile::set_filetype(::google::protobuf::int32 value) {
  _set_bit(0);
  filetype_ = value;
}

// required int64 fileindex = 2;
inline bool HandlerFile::has_fileindex() const {
  return _has_bit(1);
}
inline void HandlerFile::clear_fileindex() {
  fileindex_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 HandlerFile::fileindex() const {
  return fileindex_;
}
inline void HandlerFile::set_fileindex(::google::protobuf::int64 value) {
  _set_bit(1);
  fileindex_ = value;
}

// required bytes filename = 3;
inline bool HandlerFile::has_filename() const {
  return _has_bit(2);
}
inline void HandlerFile::clear_filename() {
  if (filename_ != &_default_filename_) {
    filename_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& HandlerFile::filename() const {
  return *filename_;
}
inline void HandlerFile::set_filename(const ::std::string& value) {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void HandlerFile::set_filename(const char* value) {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void HandlerFile::set_filename(const void* value, size_t size) {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandlerFile::mutable_filename() {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  return filename_;
}

// required int64 filesize_byte = 4;
inline bool HandlerFile::has_filesize_byte() const {
  return _has_bit(3);
}
inline void HandlerFile::clear_filesize_byte() {
  filesize_byte_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 HandlerFile::filesize_byte() const {
  return filesize_byte_;
}
inline void HandlerFile::set_filesize_byte(::google::protobuf::int64 value) {
  _set_bit(3);
  filesize_byte_ = value;
}

// required bytes lastupdatetime = 5;
inline bool HandlerFile::has_lastupdatetime() const {
  return _has_bit(4);
}
inline void HandlerFile::clear_lastupdatetime() {
  if (lastupdatetime_ != &_default_lastupdatetime_) {
    lastupdatetime_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& HandlerFile::lastupdatetime() const {
  return *lastupdatetime_;
}
inline void HandlerFile::set_lastupdatetime(const ::std::string& value) {
  _set_bit(4);
  if (lastupdatetime_ == &_default_lastupdatetime_) {
    lastupdatetime_ = new ::std::string;
  }
  lastupdatetime_->assign(value);
}
inline void HandlerFile::set_lastupdatetime(const char* value) {
  _set_bit(4);
  if (lastupdatetime_ == &_default_lastupdatetime_) {
    lastupdatetime_ = new ::std::string;
  }
  lastupdatetime_->assign(value);
}
inline void HandlerFile::set_lastupdatetime(const void* value, size_t size) {
  _set_bit(4);
  if (lastupdatetime_ == &_default_lastupdatetime_) {
    lastupdatetime_ = new ::std::string;
  }
  lastupdatetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HandlerFile::mutable_lastupdatetime() {
  _set_bit(4);
  if (lastupdatetime_ == &_default_lastupdatetime_) {
    lastupdatetime_ = new ::std::string;
  }
  return lastupdatetime_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace LogExportTask

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< LogExportTask::TaskHandler>() {
  return LogExportTask::TaskHandler_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_LogExportTask_2eproto__INCLUDED
